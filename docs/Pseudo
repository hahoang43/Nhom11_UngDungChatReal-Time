
# MÃ GIẢ LOGIC HỆ THỐNG CHAT REAL-TIME (PSEUDO-CODE)

GLOBAL Active_Clients = {} # Dictionary lưu: {username: socket_object}
FUNCTION Start_Server():
    # 1. Khởi tạo Socket TCP/IP
    server_socket = CREATE_SOCKET(AF_INET, SOCK_STREAM)
    SET_OPTIONS(server_socket, SO_REUSEADDR)
    BIND(server_socket, IP_ADDRESS, PORT)
    LISTEN(server_socket, MAX_CONNECTIONS)
    
    PRINT "Server listening on port..."

    WHILE True:
        # 2. Chấp nhận kết nối mới
        client_socket, client_addr = ACCEPT(server_socket)
        PRINT "New connection from: " + client_addr
        
        # 3. Tạo luồng (Thread) riêng để xử lý client này
        START_THREAD(Handle_Client_Connection, client_socket)

FUNCTION Handle_Client_Connection(client_socket):
    current_username = NULL
    TRY:
        WHILE True:
            # Nhận dữ liệu (Blocking call)
            raw_data = RECEIVE(client_socket, BUFFER_SIZE)
            IF NOT raw_data: BREAK # Client ngắt kết nối
            
            # Giải mã JSON
            message_json = DECODE_UTF8(raw_data)
            message_obj = PARSE_JSON(message_json)
            
            # Chuyển đến bộ xử lý trung tâm
            Process_Request(client_socket, message_obj, REF current_username)
            
    CATCH Error:
        LOG_ERROR(Error)
    FINALLY:
        # Dọn dẹp khi ngắt kết nối
        IF current_username IS NOT NULL:
            REMOVE Active_Clients[current_username]
            Broadcast_User_Status(current_username, "OFFLINE")
        CLOSE(client_socket)
## 2. XỬ LÝ YÊU CẦU TỪ CLIENT
FUNCTION Process_Request(socket, msg, REF current_username):
    SWITCH msg.type:
        CASE "AUTH":
            Handle_Auth(socket, msg, REF current_username)
            
        CASE "CHAT":
            IF msg.scope == "PRIVATE":
                Send_Private_Message(msg.sender, msg.target, msg.content)
            ELSE IF msg.scope == "GROUP":
                Broadcast_Message(msg.sender, msg.content)
                
        CASE "FILE":
            Handle_File_Transfer(socket, msg)
            
        CASE "HISTORY":
            data = DB.Get_Chat_History(msg.username1, msg.username2)
            SEND(socket, data)

FUNCTION Send_Private_Message(sender, target, content):
    IF target IN Active_Clients:
        target_socket = Active_Clients[target]
        payload = { "type": "CHAT", "sender": sender, "content": content }
        SEND(target_socket, TO_JSON(payload))
    ELSE:
        # Lưu vào DB để gửi sau hoặc báo offline
        DB.Save_Offline_Message(sender, target, content)

FUNCTION Broadcast_Message(sender, content):
    FOR user, stored_socket IN Active_Clients:
        IF user != sender:
            payload = { "type": "CHAT", "sender": sender, "content": content, "scope": "BROADCAST" }
            SEND(stored_socket, TO_JSON(payload))


3. AUTHENTICATION & DATA STORAGE

FUNCTION Handle_Auth(socket, msg, REF current_username):
    username = msg.username
    password = msg.password # Password should be hashed

    IF msg.action == "REGISTER":
        IF DB.Check_User_Exists(username):
            SEND(socket, { "type": "AUTH", "status": "FAIL", "reason": "User exists" })
        ELSE:
            DB.Add_User(username, password)
            SEND(socket, { "type": "AUTH", "status": "SUCCESS" })

    ELSE IF msg.action == "LOGIN":
        stored_pass = DB.Get_Password(username)
        IF stored_pass == password:
            current_username = username
            Active_Clients[username] = socket # Register session
            SEND(socket, { "type": "AUTH", "status": "SUCCESS" })
            Broadcast_User_Status(username, "ONLINE")
        ELSE:
            SEND(socket, { "type": "AUTH", "status": "FAIL", "reason": "Wrong password" })

4. FILE TRANSFER (BINARY OVER JSON)

# CLIENT SIDE: Gửi file
FUNCTION Client_Send_File(file_path):
    file_data = READ_BINARY(file_path)
    file_name = GET_FILENAME(file_path)
    chunks = SPLIT_INTO_CHUNKS(file_data, 4096) # 4KB per chunk
    
    FOR chunk IN chunks:
        packet = {
            "type": "FILE",
            "file_name": file_name,
            "data": BASE64_ENCODE(chunk),
            "is_eof": FALSE
        }
        SEND_SOCKET(packet)
        
    # Gửi gói kết thúc
    packet_eof = { "type": "FILE", "file_name": file_name, "is_eof": TRUE }
    SEND_SOCKET(packet_eof)

# SERVER SIDE: Forward file
FUNCTION Handle_File_Transfer(socket, msg):
    target = msg.target
    IF target IN Active_Clients:
        # Chuyển tiếp gói tin file chunk trực tiếp cho người nhận
        target_socket = Active_Clients[target]
        SEND(target_socket, TO_JSON(msg))